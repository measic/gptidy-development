[{'identified': [], 'updated_code': 'fig, axs = plt.subplots(1,2, figsize=(10,4))\naxs[0].imshow(img_advi)\naxs[0].set_title("segmented image (ADVI)")\naxs[1].hist(y, bins=K);\naxs[1].set_title("cluster assignments (ADVI)")\nplt.tight_layout()'}, {'identified': ['loss'], 'updated_code': '(_, score_vgg16_seq) = VGG16Seq.evaluate(arr_X_test, arr_y_test, verbose=True)\n\nscore_vgg16_seq'}, {'identified': ['earningscost10k', 'earningsgrowth10k', 'weighted_growth10k', 'earningscost10k_18k', 'earningsgrowth10k_18k', 'weighted_growth10k_18k', 'earningscost18k_32k', 'earningsgrowth18k_32k', 'weighted_growth18k_32k', 'earningscost32k', 'earningsgrowth32kk', 'weighted_growth32k'], 'updated_code': ''}, {'identified': ['clip2'], 'updated_code': "# Load the clip file\n_ = VideoFileClip('challenge.mp4')"}, {'identified': ['yhat'], 'updated_code': 'forecast_lstm(lstm_model, 1, X)'}, {'identified': ['describe_final'], 'updated_code': '#call pandas describe method on dataframe\ndescribe = data.describe(include = "all")\n\n#transpose\ndescribe_transposed = describe.T\n\n#reset_index, moving the column names into a new series\ndescribe_transposed.reset_index(inplace=True)'}, {'identified': ['x_values', 'y_values'], 'updated_code': ''}, {'identified': ['mfusghead'], 'updated_code': "# Create the mfusg headfile object\nheadfile = os.path.join(modelpth, '{0}.hds'.format(modelname))\nheadobj = flopy.utils.HeadFile(headfile)\ntimes = headobj.get_times()\n_ = headobj.get_data(totim=times[-1])"}, {'identified': ['fig'], 'updated_code': '_, ax = plt.subplots(figsize=(16,8))\nbp = dfBabies.boxplot(column="weight", by="smoke", ax=ax, return_type="dict")\n\nfor column in bp:\n    for box in column[\'boxes\']:\n        box.set(color=\'steelblue\', linewidth=2)\n    \n    for whisker in column[\'whiskers\']:\n        whisker.set(color=\'gray\', linewidth=2)\n\n    for cap in column[\'caps\']:\n        cap.set(color=\'gray\', linewidth=2)\n\n    for cap in column[\'medians\']:\n        cap.set(color=\'green\', linewidth=2, alpha=0.5)\n\n    for cap in column[\'fliers\']:\n        cap.set(markerfacecolor=\'steelblue\', linewidth=2, marker=\'s\', markersize=6, alpha=0.5)\n\nax.set_title(\'Weight of Smoker\\\'s Babies vs Non-Smoker\\\'s Babies\', fontsize=18)\nax.set_ylabel("Weight (in Ounces)", fontsize=16)\n\nshort_names = ["Non-Smoker", "Smoker"]\nplt.xticks(range(1,len(short_names)+1),short_names, rotation=90, fontsize=16)\n\nplt.suptitle("")\nax.set_xlabel("")\n\nax.grid(alpha=0.25)'}, {'identified': ['cadencepath', 'w'], 'updated_code': 'data = Table.read("/Users/berto/projects/LSST/cadence/LSST_DDF_2786_cadence.dat", format="ascii.commented_header")\nmjd_to_sim = data[np.logical_or(data["filter"] == "LSST_g", data["filter"] == "LSST_r")]["MJD"].data\nfilters_to_sim = convert_column_string_encoding(data[np.logical_or(data["filter"] == "LSST_g", data["filter"] == "LSST_r")]["filter"]).data'}, {'identified': ['grayscale', 'canny', 'gaussian_blur', 'region_of_interest', 'hough_lines', 'weighted_img'], 'updated_code': 'import math\n\nprevious = {\n    "right": [0, 0, 0, 0], # x1, y1, x2, y2\n    "left": [0, 0, 0, 0]\n}\n\ndef draw_lines(img, lines, color=[255, 0, 0], thickness=5):\n    global previous\n    """\n    NOTE: this is the function you might want to use as a starting point once you want to \n    average/extrapolate the line segments you detect to map out the full\n    extent of the lane (going from the result shown in raw-lines-example.mp4\n    to that shown in P1_example.mp4).  \n    \n    Think about things like separating line segments by their \n    slope ((y2-y1)/(x2-x1)) to decide which segments are part of the left\n    line vs. the right line.  Then, you can average the position of each of \n    the lines and extrapolate to the top and bottom of the lane.\n    \n    This function draws `lines` with `color` and `thickness`.    \n    Lines are drawn on the image inplace (mutates the image).\n    If you want to make the lines semi-transparent, think about combining\n    this function with the weighted_img() function below\n    """\n    sides = {\n        "left": [],\n        "right": []\n    }\n    yMin = img.shape[0]\n    xHalf = img.shape[1] / 2\n    yMax = 315\n    drawn = []\n    if lines != None:\n        for line in lines:\n            for x1,y1,x2,y2 in line:\n                slope = ((y2 - y1) / (x2 - x1))\n                if slope > 0.50 and slope < 0.8: # Right line, because of positive slope (y-reversed)\n                    sides["right"].append([x1,y1,x2,y2]) \n                elif slope < -0.50 and slope > -0.8: # Left line because of negative slope\n                    sides["left"].append([x1,y1,x2,y2])\n    yHalf = None\n    for side in sides:\n        avgSlope = None\n        totalSlope = 0\n        totalWeight = 0\n        xAvg = None\n        yAvg = None\n        for x1,y1,x2,y2 in sides[side]:\n            slope = (y2 - y1) / (x2 - x1)\n            length = math.sqrt(abs(x2-x1)^2+abs(y2 - y1)^2)\n            if xAvg == None:\n                #avgSlope = slope\n                xAvg = (x1 + x2) / 2\n                yAvg = (y1 + y2) / 2\n            else:\n                #avgSlope = (avgSlope + slope) / 2\n                xAvg = (xAvg + ((x1 + x2) / 2)) / 2\n                yAvg = (yAvg + ((y1 + y2) / 2)) / 2\n            totalSlope += slope * length\n            totalWeight += length\n        if totalWeight > 0:\n            avgSlope = totalSlope / totalWeight\n        if avgSlope != None and xAvg != None and yAvg != None:\n            yIntercept = -(avgSlope * xAvg) + yAvg\n            xMax = (yMax - yIntercept) / avgSlope\n            xMin = (yMin - yIntercept) / avgSlope\n            if side == "right":\n                offset = 20\n            else:\n                offset = -20\n            _yHalf = avgSlope * (xHalf + offset) + yIntercept \n            if yHalf == None:\n                yHalf = _yHalf\n            else:\n                xHalf = ((yHalf - yIntercept) / avgSlope) - offset\n            # cv2.line(img, (int(xMin), int(yMin)), (int(xMax), int(yMax)), color, thickness)\n            \'\'\' Switched to X at half calculation to avoid crossing lines in the extra task \'\'\'\n            points = unjitter(side, [xMin, yMin, (xHalf + offset), yHalf])\n            cv2.line(img, (int(points[0]), int(points[1])), (int(points[2]), int(points[3])), color, thickness)\n        else:\n            \'\'\' Couldn\'t accurately calculate line so going with the line of the previous frame \'\'\'\n            points = unjitter(side, previous[side])\n            cv2.line(img, (int(points[0]), int(points[1])), (int(points[2]), int(points[3])), color, thickness)\n\ndef unjitter(side, value):\n    global previous\n    alpha = 0.6\n    # destructure value\n    x1 = value[0]\n    y1 = value[1]\n    x2 = value[2]\n    y2 = value[3]\n    # set start value on first frame\n    if previous[side][0] == 0:\n        previous[side][0] = x1\n    if previous[side][1] == 0:\n        previous[side][1] = y1\n    if previous[side][2] == 0:\n        previous[side][2] = x2\n    if previous[side][3] == 0:\n        previous[side][3] = y2\n    # calculate filtered results\n    x1 = filterFn(alpha, previous[side][0], x1)\n    y1 = filterFn(alpha, previous[side][1], y1)\n    x2 = filterFn(alpha, previous[side][2], x2)\n    y2 = filterFn(alpha, previous[side][3], y2)\n    # set new values to previous\n    previous[side][0] = x1\n    previous[side][1] = y1\n    previous[side][2] = x2\n    previous[side][3] = y2\n    return [x1, y1, x2, y2]\n\ndef filterFn(alpha, prev, new):\n    return alpha * new + (1 - alpha) * prev\n\ndef clearUnjitter():\n    global previous\n    previous = {\n        "right": [0, 0, 0, 0], # x1, y1, x2, y2\n        "left": [0, 0, 0, 0]\n    }'}, {'identified': ['attr', 'is_mixed', 'df_stats', 'classifier_activation'], 'updated_code': 'def highlight_column_matches(data, column=\'\', color=\'yellow\'):\n    \'\'\'\n    highlight the maximum in a Series or DataFrame\n    \'\'\'\n    if data.ndim == 1:  # Series from .apply(axis=0) or axis=1\n        is_mixed = data == data[column]\n        return [attr if v else \'\' for v in is_mixed]\n    else:  # from .apply(axis=None)\n        is_mixed = data == data[column]\n        return pd.DataFrame(np.where(is_mixed, attr, \'\'), index=data.index, columns=data.columns)\n\ndef plot_stats(csv_filename, columns=[\'total_reward\'], **kwargs):\n    """Plot specified columns from CSV file."""\n    df_stats = pd.read_csv(csv_filename)\n    df_stats[columns].plot(**kwargs)\n\ndef save_rnn_layers(hidden_layers, output_layers):\n    for i, layer in hidden_layers.items():\n        np.save(os.path.join(vsig.out_dir, \'valid_hidden_layer_\' + i + \'_output\'), hidden_layers[i][\'output\'])\n        np.save(os.path.join(vsig.out_dir, \'valid_hidden_layer_\' + i + \'_state\'), hidden_layers[i][\'state\'])\n#     np.save(os.path.join(vsig.out_dir, \'valid_hidden_layer_2_output\'), hidden_layers[\'2\'][\'output\'])\n#     np.save(os.path.join(vsig.out_dir, \'valid_hidden_layer_2_state\'), hidden_layers[\'2\'][\'state\'])\n    np.save(os.path.join(vsig.out_dir, \'valid_output_layer\'), output_layers)\n    \ndef save_mlp_layers(hidden_layers, output_layers):\n    for i, layer in hidden_layers.items():\n        np.save(os.path.join(vsig.out_dir, \'valid_hidden_layer_\' + i + \'_output\'), layer)\n    np.save(os.path.join(vsig.out_dir, \'valid_output_layer\'), output_layers)\n    \ndef glance_at_tensor(tensor):\n    if len(tensor.shape) == 3:\n        print(tensor[:10, 0, 0])\n        print(tensor[0, :10, 0])\n        print(tensor[0, 0, :10])\n        print(\'\')\n        print(tensor[-10:, -1, -1])\n        print(tensor[-1, -10:, -1])\n        print(tensor[-1, -1, -10:])\n    elif len(tensor.shape) == 4:\n        print(tensor[:10, 0, 0, 0])\n        print(tensor[0, :10, 0, 0])\n        print(tensor[0, 0, :10, 0])\n        print(tensor[0, 0, 0, :10])\n        print(\'\')\n        print(tensor[-10:, -1, -1, -1])\n        print(tensor[-1, -10:, -1, -1])\n        print(tensor[-1, -1, -10:, -1])\n        print(tensor[-1, -1, -1, -10:])'}, {'identified': ['x_values', 'y_values', 'm', 'b', 'x'], 'updated_code': 'def error_line_trace(_, _, _, _, _):\n    pass'}, {'identified': [], 'updated_code': 'beta = sp.stats.beta.rvs(1, alpha, size=(N, K))\nw = np.empty_like(beta)\nw[:, 0] = beta[:, 0]\nw[:, 1:] = beta[:, 1:] * (1 - beta[:, :-1]).cumprod(axis=1)\n\nomega = P0.rvs(size=(N, K))\n\nx_plot = np.linspace(-3, 3, 200)\n\nsample_cdfs = (w[..., np.newaxis] * np.less.outer(omega, x_plot)).sum(axis=1)'}, {'identified': ['num_inserted'], 'updated_code': 'def insert_and_time_filter_bloom_filter(capacity, percent_fill=0.9):\n    b_filter = CountingBloomFilter(capacity)\n    now = time.time()\n    for i in range(int(percent_fill*capacity)):\n        b_filter.add(str(i))\n    elapsed_insertion = time.time() - now\n    return b_filter, elapsed_insertion'}, {'identified': [], 'updated_code': "targets = np.array(['Vessel underway (stern)',\n                    'Power-driven vessel underway (>50m in length) (starboard)',\n                    'Power-driven vessel underway (>50m in length) (port)',\n                    'Power-driven vessel underway (>50m in length) (bow)',\n                    'Power-driven vessel underway (<50m in length) (starboard)',\n                    'Power-driven vessel underway (<50m in length) (port)',\n                    'Power-driven vessel underway (<50m in length) (bow)'], dtype=np.dtype('unicode_'))"}, {'identified': ['cb'], 'updated_code': "fig = plt.figure(figsize=(12, 7))\n\nax1 = fig.add_subplot(231)\np = ax1.pcolor(inc, scr, ZU)\nc = ax1.contour(inc, scr, ZU, [0.92, 0.94, 0.96, 0.98], colors=['k', 'k', 'k', 'k'])\nplt.clabel(c, manual=[(0.02, 0.25), (0.05, 0.25), (0.07, 0.15), (0.09, 0.05)], fmt='%1.2f')\nfig.colorbar(p, ax=ax1)\nax1.set_ylabel('Screening Rate (years $^{-1}$)')\nt = ax1.text(0.05, 0.45, 'Uninfected', ha='center', size='large')\nt.set_bbox(dict(facecolor='white', alpha=0.7, edgecolor='None'))\nax1.set_ylim(0, 0.5)\nax1.set_xlim(0, 0.1)\n\nax2 = fig.add_subplot(232)\np = ax2.pcolor(inc, scr, ZS)\nc = ax2.contour(inc, scr, ZS, (0.001, 0.002, 0.003), colors='k', manual=True)\nplt.clabel(c, manual=[(0.03, 0.15), (0.06, 0.15), (0.09, 0.15)], fmt='%1.3f')\nfig.colorbar(p, ax=ax2)\nt = ax2.text(0.05, 0.45, 'Infected, Symptomatic', ha='center', size='large')\nt.set_bbox(dict(facecolor='white', alpha=0.7, edgecolor='None'))\nax2.set_ylim(0, 0.5)\nax2.set_xlim(0, 0.1)\n\nax3 = fig.add_subplot(233)\np = ax3.pcolor(inc, scr, ZA)\nc = ax3.contour(inc, scr, ZA, (0.02, 0.04, 0.06, 0.08), colors='k')\nplt.clabel(c, manual=[(0.02, 0.25), (0.05, 0.25), (0.07, 0.15), (0.09, 0.05)], fmt='%1.2f')\nfig.colorbar(p, ax=ax3)\nt = ax3.text(0.05, 0.45, 'Infected, Asymptomatic', ha='center', size='large')\nt.set_bbox(dict(facecolor='white', alpha=0.7, edgecolor='None'))\nax3.set_ylim(0, 0.5)\nax3.set_xlim(0, 0.1)\n\nax4 = fig.add_subplot(234)\np = ax4.pcolor(inc, scr, Zprev)\nc = ax4.contour(inc, scr, Zprev, (0.02, 0.04, 0.06, 0.08), colors='k')\nplt.clabel(c, manual=[(0.02, 0.25), (0.05, 0.25), (0.07, 0.15), (0.09, 0.05)], fmt='%1.2f')\nfig.colorbar(p, ax=ax4)\nax4.set_xlabel('Incidence  (years $^{-1}$)')\nax4.set_ylabel('Screening Rate (years $^{-1}$)')\nt = ax4.text(0.05, 0.45, 'Prevalence', ha='center', size='large')\nt.set_bbox(dict(facecolor='white', alpha=0.7, edgecolor='None'))\nax4.set_ylim(0, 0.5)\nax4.set_xlim(0, 0.1)\n\nax5 = fig.add_subplot(235)\np = ax5.pcolor(inc, scr, Ztest)\nc = ax5.contour(inc, scr, Ztest, (0.2, 0.4), colors='k')\nplt.clabel(c, manual=[(0.045, 0.2), (0.045, 0.5)], fmt='%1.1f')\nfig.colorbar(p, ax=ax5)\nax5.set_xlabel('Incidence  (years $^{-1}$)')\nt = ax5.text(0.05, 0.45, 'Testing Rate', ha='center', size='large')\nt.set_bbox(dict(facecolor='white', alpha=0.7, edgecolor='None'))\nax5.set_ylim(0, 0.5)\nax5.set_xlim(0, 0.1)\n\nax6 = fig.add_subplot(236)\np = ax6.pcolor(inc, scr, Zdiag)\nc = ax6.contour(inc, scr, Zdiag, (0.02, 0.04, 0.06), colors='k')\nplt.clabel(c, manual=[(0.04, 0.2), (0.06, 0.4), (0.09, 0.35)], fmt='%1.2f')\nfig.colorbar(p, ax=ax6)\nax6.set_xlabel('Incidence (years $^{-1}$)')\nt = ax6.text(0.05, 0.45, 'Diagnosis Rate', ha='center', size='large')\nt.set_bbox(dict(facecolor='white', alpha=0.7, edgecolor='None'))\nax6.set_ylim(0, 0.5)\nax6.set_xlim(0, 0.1)\n\nplt.show()"}, {'identified': ['name'], 'updated_code': "for (_, prd) in ('lr', log_clf), ('rf', rnd_clf), ('svc', svm_clf):\n    prd.fit(X_train, y_train)"}, {'identified': ['burned_trace'], 'updated_code': '#include the observations, which are Bernoulli\nwith model:\n    obs = pm.Bernoulli("obs", p, observed=occurrences)\n    # To be explained in chapter 3\n    step = pm.Metropolis()\n    trace = pm.sample(18000, step=step)'}, {'identified': [], 'updated_code': '# Action Directions\nnorth = (0, 1)\nsouth = (0,-1)\nwest = (-1, 0)\neast = (1, 0)\n\npolicy = {\n    (0, 2): east,  (1, 2): east,  (2, 2): east,   (3, 2): None,\n    (0, 1): north,                (2, 1): north,  (3, 1): None,\n    (0, 0): north, (1, 0): west,  (2, 0): west,   (3, 0): west, \n}\n'}]