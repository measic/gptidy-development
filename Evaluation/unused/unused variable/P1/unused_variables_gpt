[{'reason': 'stop', 'result': 'Unused variables: None\n\nUpdated code:\n```python\nfig, axs = plt.subplots(1,2, figsize=(10,4))\naxs[0].imshow(img_advi)\naxs[0].set_title("segmented image (ADVI)")\naxs[1].hist(y, bins=K);\naxs[1].set_title("cluster assignments (ADVI)")\nplt.tight_layout()```'}, {'reason': 'stop', 'result': 'Unused variables:\n- loss\n\nUpdated code:\n```python\nscore_vgg16_seq = VGG16Seq.evaluate(arr_X_test, arr_y_test, verbose=True)\n\nscore_vgg16_seq```'}, {'reason': 'stop', 'result': "Unused variables:\n- earningscost10k_18k\n- earningsgrowth10k_18k\n- weighted_growth10k_18k\n- earningscost18k_32k\n- earningsgrowth18k_32k\n- weighted_growth18k_32k\n- earningsgrowth32kk\n\nUpdated code:\n```python\n#set up lists containing calculated rations for plotting \nearningscost10k = [earningscost for earningscost in df0_10k_grouped['earnings_cost_ratio']]\nearningsgrowth10k = [earnings for earnings in df0_10k_grouped['earnings_growth_y6_y10']]\nweighted_growth10k = [worthit for worthit in df0_10k_grouped['weighted_growth_to_tuition']]\n\nearningscost32k = [earningscost for earningscost in df32_grouped['earnings_cost_ratio']]\nweighted_growth32k = [worthit for worthit in df32_grouped['weighted_growth_to_tuition']]\n```"}, {'reason': 'stop', 'result': "Unused variables: []\n\nUpdated code:\n```python\n# Load the clip file\nVideoFileClip('challenge.mp4')```"}, {'reason': 'stop', 'result': 'Unused variables: []\n\nUpdated code:\n```python\nforecast_lstm(lstm_model, 1, X)\n```'}, {'reason': 'stop', 'result': 'Unused variables:\n- `describe`\n\nUpdated code:\n```python\n#call pandas describe method on dataframe\ndescribe_transposed = data.describe(include = "all").T\n\n#reset_index, moving the column names into a new series\ndescribe_final = describe_transposed.reset_index()```'}, {'reason': 'stop', 'result': 'Unused variables:\n- x_values\n- y_values\n\nUpdated code:\n```python\n# No changes needed as the unused variables have already been removed\n```'}, {'reason': 'stop', 'result': "Unused variables:\n- `mfusghead`\n\nUpdated code:\n```python\n# Create the mfusg headfile object\nheadfile = os.path.join(modelpth, '{0}.hds'.format(modelname))\nheadobj = flopy.utils.HeadFile(headfile)\ntimes = headobj.get_times()\n_ = headobj.get_data(totim=times[-1])  # Unused variable removed\n```"}, {'reason': 'stop', 'result': 'Unused variables: None\n\nUpdated code:\n```python\nfig, ax = plt.subplots(figsize=(16,8))\nbp = dfBabies.boxplot(column="weight", by="smoke", ax=ax, return_type="dict")\n\nfor column in bp:\n    for box in column[\'boxes\']:\n        box.set(color=\'steelblue\', linewidth=2)\n    \n    for whisker in column[\'whiskers\']:\n        whisker.set(color=\'gray\', linewidth=2)\n\n    for cap in column[\'caps\']:\n        cap.set(color=\'gray\', linewidth=2)\n\n    for cap in column[\'medians\']:\n        cap.set(color=\'green\', linewidth=2, alpha=0.5)\n\n    for cap in column[\'fliers\']:\n        cap.set(markerfacecolor=\'steelblue\', linewidth=2, marker=\'s\', markersize=6, alpha=0.5)\n\nax.set_title(\'Weight of Smoker\\\'s Babies vs Non-Smoker\\\'s Babies\', fontsize=18)\nax.set_ylabel("Weight (in Ounces)", fontsize=16)\n\nshort_names = ["Non-Smoker", "Smoker"]\nplt.xticks(range(1,len(short_names)+1),short_names, rotation=90, fontsize=16)\n\nplt.suptitle("")\nax.set_xlabel("")\n\nax.grid(alpha=0.25)\n```'}, {'reason': 'stop', 'result': 'Unused variables:\n- `w`\n\nUpdated code:\n```python\ncadencepath = "/Users/berto/projects/LSST/cadence/LSST_DDF_2786_cadence.dat"\n\ndata = Table.read(cadencepath, format="ascii.commented_header")\nmjd_to_sim = data[np.logical_or(data["filter"] == "LSST_g", data["filter"] == "LSST_r")]["MJD"].data\nfilters_to_sim = convert_column_string_encoding(data[np.logical_or(data["filter"] == "LSST_g", data["filter"] == "LSST_r")]["filter"]).data\n```'}, {'reason': 'length', 'result': 'Unused variables: [\'yHalf\']\n\nUpdated code:\n```python\nimport math\nprevious = {\n    "right": [0, 0, 0, 0], # x1, y1, x2, y2\n    "left": [0, 0, 0, 0]\n}\n\ndef grayscale(img):\n    """Applies the Grayscale transform\n    This will return an image with only one color channel\n    but NOTE: to see the returned image as grayscale\n    you should call plt.imshow(gray, cmap=\'gray\')"""\n    return cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    # Or use BGR2GRAY if you read an image with cv2.imread()\n    # return cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    \ndef canny(img, low_threshold, high_threshold):\n    """Applies the Canny transform"""\n    return cv2.Canny(img, low_threshold, high_threshold)\n\ndef gaussian_blur(img, kernel_size):\n    """Applies a Gaussian Noise kernel"""\n    return cv2.GaussianBlur(img, (kernel_size, kernel_size), 0)\n\ndef region_of_interest(img, vertices):\n    """\n    Applies an image mask.\n    \n    Only keeps the region of the image defined by the polygon\n    formed from `vertices`. The rest of the image is set to black.\n    """\n    #defining a blank mask to start with\n    mask = np.zeros_like(img)   \n    \n    #defining a 3 channel or 1 channel color to fill the mask with depending on the input image\n    if len(img.shape) > 2:\n        channel_count = img.shape[2]  # i.e. 3 or 4 depending on your image\n        ignore_mask_color = (255,) * channel_count\n    else:\n        ignore_mask_color = 255\n        \n    #filling pixels inside the polygon defined by "vertices" with the fill color    \n    cv2.fillPoly(mask, vertices, ignore_mask_color)\n    \n    #returning the image only where mask pixels are nonzero\n    masked_image = cv2.bitwise_and(img, mask)\n    return masked_image\n\n\'\'\' Calculate filtered results \'\'\'\ndef filterFn(alpha, prev, new):\n    return alpha * new + (1 - alpha) * prev\n\n\'\'\' Clear global previous between videos \'\'\'\ndef clearUnjitter():\n    global previous\n    previous = {\n        "right": [0, 0, 0, 0], # x1, y1, x2, y2\n        "left": [0, 0, 0, 0]\n    }\n\n\'\'\'\nUnjitter it as tipped by Vivek Jadav in the following topic:\nhttps://carnd-forums.udacity.com/display/CAR/questions/22086201/p1-how-to-avoid-jittery-lines\n\'\'\'\ndef unjitter(side, value):\n    global previous\n    alpha = 0.6\n    # destructure value\n    x1 = value[0]\n    y1 = value[1]\n    x2 = value[2]\n    y2 = value[3]\n    # set start value on first frame\n    if previous[side][0] == 0:\n        previous[side][0] = x1\n    if previous[side][1] == 0:\n        previous[side][1] = y1\n    if previous[side][2] == 0:\n        previous[side][2] = x2\n    if previous[side][3] == 0:\n        previous[side][3] = y2\n    # calculate filtered results\n    x1 = filterFn(alpha, previous[side][0], x1)\n    y1 = filterFn(alpha, previous[side][1], y1)\n    x2 = filterFn(alpha, previous[side][2], x2)\n    y2 = filterFn(alpha, previous[side][3], y2)\n    # set new values to previous\n    previous[side][0] = x1\n    previous[side][1] = y1\n    previous[side][2] = x2\n    previous[side][3] = y2\n    return [x1, y1, x2, y2]\n\ndef draw_lines(img, lines, color=[255, 0, 0], thickness=5):\n    global previous\n    """\n    NOTE: this is the function you might want to use as a starting point once you want to \n    average/extrapolate the line segments you detect to map out the full\n    extent of the lane (going from the result shown in raw-lines-example.mp4\n    to that shown in P1_example.mp4).  \n    \n    Think about things like separating line segments by their \n    slope ((y2-y1)/(x2-x1)) to decide which segments are part of the left\n    line vs. the right line.  Then, you can average the position of each of \n    the lines and extrapolate to the top and bottom of the lane.\n    \n    This function draws `lines` with `color` and `thickness`.    \n    Lines are drawn on the image inplace (mutates the image).\n    If you want to make the lines semi-transparent, think about combining\n    this function with the weighted_img() function below\n    """\n    sides = {\n        "left": [],\n        "right": []\n    }\n    yMin = img.shape[0]\n    xHalf = img.shape[1] / 2\n    yMax = 315\n    drawn = []\n    if lines != None:\n        for line in lines:\n            for x1,y1,x2,y2 in line:\n                slope = ((y2 - y1) / (x2 - x1))\n                if slope > 0.50 and slope < 0.8: # Right line, because of positive slope (y-reversed)\n                    sides["right"].append([x1,y1,x2,y2]) \n                elif slope < -0.50 and slope > -0.8: # Left line because of negative slope\n                    sides["left"].append([x1,y1,x2,y2])\n    for side in sides:\n        avgSlope = None\n        totalSlope = 0\n        totalWeight = 0\n        xAvg = None\n        yAvg = None\n        for x1,y1,x2,y2 in sides[side]:\n            slope = (y2 - y1) / (x2 - x1)\n            length = math.sqrt(abs(x2-x1)^2+abs(y2 - y1)^2)\n            if xAvg == None:\n                #avgSlope = slope\n                xAvg = (x1 + x2) / 2\n                yAvg = (y1 + y2) / 2\n            else:\n                #avgSlope = (avgSlope + slope) / 2\n                xAvg = (xAvg + ((x1 + x2) / 2)) / 2\n                yAvg = (yAvg + ((y1 + y2) / 2)) / 2\n            totalSlope += slope * length\n            totalWeight += length\n        if totalWeight > 0:\n            avgSlope = totalSlope / totalWeight\n        if avgSlope != None and xAvg != None and yAvg != None:\n            yIntercept = -(avgSlope * xAvg) + yAvg\n            xMax = (yMax - yIntercept) / avgSlope\n            xMin = (yMin - yIntercept) / avgSlope\n            if side == "right":\n                offset = 20\n            else:\n                offset = -20\n            points = unjitter(side, [xMin, yMin, (xHalf + offset), yHalf])\n            cv2.line(img, (int(points[0]), int(points[1])), (int(points[2]), int(points[3])), color, thickness)\n        else:\n            \'\'\' Couldn\'t accurately calculate line so going with the line of the previous frame \'\'\'\n            points = unjitter(side, previous[side])\n            cv2.line(img, (int(points[0]), int(points[1])), (int(points[2]), int(points[3])), color, thickness)\n\ndef hough_lines(img, rho, theta, threshold, min_line_len, max_line_gap):\n    """\n    `img` should be the output of a Canny transform.\n        \n    Returns an image with hough lines drawn.\n    """\n    lines = cv2.HoughLinesP(img, rho, theta, threshold, np.array([]), minLineLength=min_line_len, maxLineGap=max_line_gap)\n    line_img = np.zeros((*img.shape, 3), dtype=np.uint8)\n    draw_lines(line_img, lines)\n    return line_img\n\n# Python 3 has support for cool math symbols.\n\ndef weighted_img(img, initial_img, α=0.8, β=1., λ=0.):\n    """\n    `img` is the output of the hough_lines(), An image with lines drawn'}, {'reason': 'stop', 'result': 'Unused variables:\n- `layer` in the function `save_mlp_layers`\n\nUpdated code:\n```python\ndef highlight_column_matches(data, column=\'\', color=\'yellow\'):\n    \'\'\'\n    highlight the maximum in a Series or DataFrame\n    \'\'\'\n    attr = \'background-color: {}\'.format(color)\n    if data.ndim == 1:  # Series from .apply(axis=0) or axis=1\n        is_mixed = data == data[column]\n        return [attr if v else \'\' for v in is_mixed]\n    else:  # from .apply(axis=None)\n        is_mixed = data == data[column]\n        return pd.DataFrame(np.where(is_mixed, attr, \'\'), index=data.index, columns=data.columns)\n\ndef plot_stats(csv_filename, columns=[\'total_reward\'], **kwargs):\n    """Plot specified columns from CSV file."""\n    df_stats = pd.read_csv(csv_filename)\n    df_stats[columns].plot(**kwargs)\n\ndef save_rnn_layers(hidden_layers, output_layers):\n    for i, layer in hidden_layers.items():\n        np.save(os.path.join(vsig.out_dir, \'valid_hidden_layer_\' + i + \'_output\'), hidden_layers[i][\'output\'])\n        np.save(os.path.join(vsig.out_dir, \'valid_hidden_layer_\' + i + \'_state\'), hidden_layers[i][\'state\'])\n#     np.save(os.path.join(vsig.out_dir, \'valid_hidden_layer_2_output\'), hidden_layers[\'2\'][\'output\'])\n#     np.save(os.path.join(vsig.out_dir, \'valid_hidden_layer_2_state\'), hidden_layers[\'2\'][\'state\'])\n    np.save(os.path.join(vsig.out_dir, \'valid_output_layer\'), output_layers)\n    \ndef save_mlp_layers(hidden_layers, output_layers):\n    for i, _ in hidden_layers.items():\n        np.save(os.path.join(vsig.out_dir, \'valid_hidden_layer_\' + i + \'_output\'), hidden_layers[i][\'output\'])\n    np.save(os.path.join(vsig.out_dir, \'valid_output_layer\'), output_layers)\n    \ndef glance_at_tensor(tensor):\n    if len(tensor.shape) == 3:\n        print(tensor[:10, 0, 0])\n        print(tensor[0, :10, 0])\n        print(tensor[0, 0, :10])\n        print(\'\')\n        print(tensor[-10:, -1, -1])\n        print(tensor[-1, -10:, -1])\n        print(tensor[-1, -1, -10:])\n    elif len(tensor.shape) == 4:\n        print(tensor[:10, 0, 0, 0])\n        print(tensor[0, :10, 0, 0])\n        print(tensor[0, 0, :10, 0])\n        print(tensor[0, 0, 0, :10])\n        print(\'\')\n        print(tensor[-10:, -1, -1, -1])\n        print(tensor[-1, -10:, -1, -1])\n        print(tensor[-1, -1, -10:, -1])\n        print(tensor[-1, -1, -1, -10:])\n        \nclassifier_activation = {\'binary\': \'sigmoid\', \'categorical\': \'softmax\'}\n```'}, {'reason': 'stop', 'result': "Unused variables: ['x_values', 'y_values', 'm', 'b', 'x']\n\nUpdated code:\n```python\ndef error_line_trace():\n    pass\n```"}, {'reason': 'stop', 'result': 'Unused variables: None\n\nUpdated code:\n```python\nbeta = sp.stats.beta.rvs(1, alpha, size=(N, K))\nw = np.empty_like(beta)\nw[:, 0] = beta[:, 0]\nw[:, 1:] = beta[:, 1:] * (1 - beta[:, :-1]).cumprod(axis=1)\n\nomega = P0.rvs(size=(N, K))\n\nx_plot = np.linspace(-3, 3, 200)\n\nsample_cdfs = (w[..., np.newaxis] * np.less.outer(omega, x_plot)).sum(axis=1)\n```'}, {'reason': 'stop', 'result': "Unused variables: ['num_inserted']\n\nUpdated code:\n```python\ndef insert_and_time_filter_bloom_filter(capacity, percent_fill=0.9):\n    b_filter = CountingBloomFilter(capacity)\n    now = time.time()\n    for i in range(int(percent_fill*capacity)):\n        b_filter.add(str(i))\n    elapsed_insertion = time.time() - now\n    return b_filter, elapsed_insertion```"}, {'reason': 'stop', 'result': "Unused variables:\n- None\n\nUpdated code:\n```python\ntargets = np.array(['Vessel underway (stern)',\n                    'Power-driven vessel underway (>50m in length) (starboard)',\n                    'Power-driven vessel underway (>50m in length) (port)',\n                    'Power-driven vessel underway (>50m in length) (bow)',\n                    'Power-driven vessel underway (<50m in length) (starboard)',\n                    'Power-driven vessel underway (<50m in length) (port)',\n                    'Power-driven vessel underway (<50m in length) (bow)'], dtype=np.dtype('unicode_'))\n```"}, {'reason': 'stop', 'result': "Unused variables: ['cb']\n\nUpdated code:\n```python\nfig = plt.figure(figsize = (12, 7))\n\nax1 = fig.add_subplot(231)\np = ax1.pcolor(inc,scr, ZU)\nc = ax1.contour(inc,scr, ZU, [0.92,0.94,0.96,0.98], colors=['k','k','k','k'])\nplt.clabel(c, manual = [(0.02,0.25), (0.05,0.25), (0.07,0.15), (0.09,0.05)], fmt='%1.2f')\nfig.colorbar(p, ax=ax1)\n#ax1.set_xlabel('Incidence')\nax1.set_ylabel('Screening Rate (years $^{-1}$)')\nt = ax1.text(0.05, 0.45, 'Uninfected', ha='center', size='large')\nt.set_bbox(dict(facecolor='white', alpha=0.7, edgecolor='None'))\nax1.set_ylim(0, 0.5)\nax1.set_xlim(0, 0.1)\n\nax2 = fig.add_subplot(232)\np = ax2.pcolor(inc,scr, ZS)\nc = ax2.contour(inc,scr, ZS, (0.001,0.002,0.003), colors='k', manual=True)\nplt.clabel(c, manual = [(0.03,0.15), (0.06,0.15), (0.09,0.15)], fmt='%1.3f')\nfig.colorbar(p, ax=ax2)\nt = ax2.text(0.05, 0.45, 'Infected, Symptomatic', ha='center', size='large')\nt.set_bbox(dict(facecolor='white', alpha=0.7, edgecolor='None'))\nax2.set_ylim(0, 0.5)\nax2.set_xlim(0, 0.1)\n\nax3 = fig.add_subplot(233)\np = ax3.pcolor(inc,scr, ZA)\nc = ax3.contour(inc,scr, ZA, (0.02,0.04,0.06,0.08), colors='k')\nplt.clabel(c, manual = [(0.02,0.25), (0.05,0.25), (0.07,0.15), (0.09,0.05)], fmt='%1.2f')\nfig.colorbar(p, ax=ax3)\nt = ax3.text(0.05, 0.45, 'Infected, Asymptomatic', ha='center', size='large')\nt.set_bbox(dict(facecolor='white', alpha=0.7, edgecolor='None'))\nax3.set_ylim(0, 0.5)\nax3.set_xlim(0, 0.1)\n\nax4 = fig.add_subplot(234)\np = ax4.pcolor(inc,scr, Zprev)\nc = ax4.contour(inc,scr, Zprev, (0.02,0.04,0.06,0.08), colors='k')\nplt.clabel(c, manual = [(0.02,0.25), (0.05,0.25), (0.07,0.15), (0.09, 0.05)], fmt='%1.2f')\nfig.colorbar(p, ax=ax4)\nax4.set_xlabel('Incidence  (years $^{-1}$)')\nax4.set_ylabel('Screening Rate (years $^{-1}$)')\nt = ax4.text(0.05, 0.45, 'Prevalence', ha='center', size='large')\nt.set_bbox(dict(facecolor='white', alpha=0.7, edgecolor='None'))\nax4.set_ylim(0, 0.5)\nax4.set_xlim(0, 0.1)\n\nax5 = fig.add_subplot(235)\np = ax5.pcolor(inc,scr, Ztest)\nc = ax5.contour(inc,scr, Ztest, (0.2,0.4), colors='k')\nplt.clabel(c, manual = [(0.045,0.2), (0.045,0.5)], fmt='%1.1f')\nfig.colorbar(p, ax=ax5)\nax5.set_xlabel('Incidence  (years $^{-1}$)')\nt = ax5.text(0.05, 0.45, 'Testing Rate', ha='center', size='large')\nt.set_bbox(dict(facecolor='white', alpha=0.7, edgecolor='None'))\nax5.set_ylim(0, 0.5)\nax5.set_xlim(0, 0.1)\n\nax6 = fig.add_subplot(236)\np = ax6.pcolor(inc,scr, Zdiag)\nc = ax6.contour(inc,scr, Zdiag, (0.02,0.04,0.06), colors='k')\nplt.clabel(c, manual = [(0.04,0.2), (0.06,0.4), (0.09,0.35)], fmt='%1.2f')\nfig.colorbar(p, ax=ax6)\nax6.set_xlabel('Incidence (years $^{-1}$)')\nt = ax6.text(0.05, 0.45, 'Diagnosis Rate', ha='center', size='large')\nt.set_bbox(dict(facecolor='white', alpha=0.7, edgecolor='None'))\nax6.set_ylim(0, 0.5)\nax6.set_xlim(0, 0.1)\n\nplt.show()\n```"}, {'reason': 'stop', 'result': "Unused variables:\n- name\n\nUpdated code:\n```python\nfor (_, prd) in ('lr', log_clf), ('rf', rnd_clf), ('svc', svm_clf):\n    prd.fit(X_train, y_train)```"}, {'reason': 'stop', 'result': 'Unused variables:\n- `obs`\n\nUpdated code:\n```python\n#include the observations, which are Bernoulli\nwith model:\n    # To be explained in chapter 3\n    step = pm.Metropolis()\n    trace = pm.sample(18000, step=step)\n    burned_trace = trace[1000:]```'}, {'reason': 'stop', 'result': "Unused variables: ['south']\n\nUpdated code:\n```python\n# Action Directions\nnorth = (0, 1)\nwest = (-1, 0)\neast = (1, 0)\n\npolicy = {\n    (0, 2): east,  (1, 2): east,  (2, 2): east,   (3, 2): None,\n    (0, 1): north,                (2, 1): north,  (3, 1): None,\n    (0, 0): north, (1, 0): west,  (2, 0): west,   (3, 0): west, \n}\n```"}]